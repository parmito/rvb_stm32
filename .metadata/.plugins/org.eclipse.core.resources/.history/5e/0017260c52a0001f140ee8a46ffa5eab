/*
 * TaskAppSerial.c
 *
 *  Created on: Nov 11, 2024
 *      Author: volkswagen2
 */
#include "TaskAppSerial.h"
extern void vTimerCallbackAppSerial(void const * argument);
sMessageType stAppSerialMsg;
static unsigned char ucCurrentStateAppSerial = TASK_APPCAN_INITIALIZING;
static QueueHandle_t *xQueueAppSerial;
static TimerHandle_t xTimerAppSerial;

#define FIFO_SIZE 8
static uint8_t u8FifoRxUSART = 0;
static uint8_t u8FifoTxUSART = 0;
static uint16_t u16TimeSlice = 0;


//////////////////////////////////////////////
//
//
//              TaskAppSerial_Entry
//
//
//////////////////////////////////////////////
void TaskAppSerial_Entry(QueueHandle_t *xQueue,TimerHandle_t xTimer)
{
    xQueueAppSerial = xQueue;
    xTimerAppSerial = xTimer;

    hCAN = hGet_CAN_Handler();

    stAppSerialMsg.ucSrc = SRC_APPCAN;
    stAppSerialMsg.ucDest = SRC_APPCAN;
    stAppSerialMsg.ucEvent = EVENT_APPCAN_INIT;
    xQueueGenericSend(*xQueueAppSerial, ( void * )&stAppSerialMsg, 0,0);
}
//////////////////////////////////////////////
//
//
//              TaskAppSerial_Start
//
//
//////////////////////////////////////////////
unsigned char TaskAppSerial_Start(sMessageType *psMessage)
{
    unsigned char boError = true;

    (void)stHAL_CAN_FilterConfig();
    (void)HAL_CAN_Start(hCAN);

	return boError;
}


//////////////////////////////////////////////
//
//
//              TaskAppSerial_ReceiveEvent
//
//
//////////////////////////////////////////////
unsigned char TaskAppSerial_ReceiveEvent(sMessageType *psMessage)
{
    unsigned char boError = true;

    tstFrameCAN *pstFrameCAN = (tstFrameCAN*)(psMessage->pcMessageData);

	return boError;
}

//////////////////////////////////////////////
//
//
//              TaskAppSerial_TransmitEvent
//
//
//////////////////////////////////////////////
unsigned char TaskAppSerial_TransmitEvent(sMessageType *psMessage)
{
    unsigned char boError = true;
    uint32_t u32;


    pTxHeader.StdId = 0x3C0;
    pTxHeader.IDE = CAN_ID_STD;
    pTxHeader.RTR = CAN_RTR_DATA;
    pTxHeader.DLC = 4;

    memset(stFrameTxCAN[u8FifoTxCAN].u8Data,0,sizeof(stFrameTxCAN[0].u8Data));

    stFrameTxCAN[u8FifoTxCAN].u8Data[0] = 0xC1;
    stFrameTxCAN[u8FifoTxCAN].u8Data[1] = 0x01;
    stFrameTxCAN[u8FifoTxCAN].u8Data[2] = 0x03;
    stFrameTxCAN[u8FifoTxCAN].u8Data[3] = 0x00;

	u32 = HAL_CAN_GetTxMailboxesFreeLevel(hCAN);
    if(u32 > 0)
    {
        (void)HAL_CAN_AddTxMessage(hCAN, &pTxHeader,stFrameTxCAN[u8FifoTxCAN].u8Data, &u32TxMailbox);
    }
	return boError;
}

//////////////////////////////////////////////
//
//
//              TaskAppSerial_IgnoreEvent
//
//
//////////////////////////////////////////////
unsigned char TaskAppSerial_IgnoreEvent(sMessageType *psMessage)
{
    unsigned char boError = false;

    return(boError);
}

//////////////////////////////////////////////
//
//
//              vTimerCallbackAppSerial
//
//
//////////////////////////////////////////////
void vTimerCallbackAppSerial(void const * argument)
 {

 }
//////////////////////////////////////////////
//
//
//             APP CAN State Machine
//
//
//////////////////////////////////////////////
static sStateMachineType const gasTaskAppSerial_Initializing[] =
{
    /* Event        Action routine      Next state */
    /*  State specific transitions	*/
    {EVENT_APPCAN_INIT,       TaskAppSerial_Start,             TASK_APPCAN_RUNNING,         	TASK_APPCAN_INITIALIZING   	},
    {EVENT_APPCAN_NULL,       TaskAppSerial_IgnoreEvent,       TASK_APPCAN_INITIALIZING,		TASK_APPCAN_INITIALIZING		}
};

static sStateMachineType const gasTaskAppSerial_Running[] =
{
    /* Event        Action routine      Next state */
    /*  State specific transitions	*/
    {EVENT_APPCAN_RX,       TaskAppSerial_ReceiveEvent,	   	TASK_APPCAN_RUNNING,			TASK_APPCAN_RUNNING		},
    {EVENT_APPCAN_TX,       TaskAppSerial_TransmitEvent,     	TASK_APPCAN_RUNNING,			TASK_APPCAN_RUNNING		},
    {EVENT_APPCAN_NULL,     TaskAppSerial_IgnoreEvent,        	TASK_APPCAN_RUNNING,			TASK_APPCAN_RUNNING		}
};

static sStateMachineType const * const gpasTaskAppSerial_StateMachine[] =
{
	gasTaskAppSerial_Initializing,
	gasTaskAppSerial_Running
};

static uint8_t u8TogglePin = 0;

void vTaskAppSerial(void const * argument)
{
	if( xQueueReceive( *xQueueAppSerial, &stAppSerialMsg, 0 ) )
	{
		(void)eEventHandler ((unsigned char)SRC_APPCAN,gpasTaskAppSerial_StateMachine[ucCurrentStateAppSerial], &ucCurrentStateAppSerial, &stAppSerialMsg);
	}

	if( HAL_CAN_GetRxFifoFillLevel(hCAN, CAN_RX_FIFO0) > 0)
	{
		memset(stFrameRxCAN[u8FifoRxCAN].u8Data,0,sizeof(stFrameRxCAN[0].u8Data));
		if(HAL_CAN_GetRxMessage(hCAN, CAN_RX_FIFO0,&pRxHeader,stFrameRxCAN[u8FifoRxCAN].u8Data) == HAL_OK)
		{
			stAppSerialMsg.ucSrc = SRC_APPCAN;
			stAppSerialMsg.ucDest = SRC_APPCAN;
			stAppSerialMsg.ucEvent = EVENT_APPCAN_RX;
			stFrameRxCAN[u8FifoRxCAN].u32ID = pRxHeader.StdId;
			stFrameRxCAN[u8FifoRxCAN].u32DLC = pRxHeader.DLC;
			stAppSerialMsg.pcMessageData = (char*)&stFrameRxCAN[u8FifoRxCAN];
			xQueueGenericSend(*xQueueAppSerial, ( void * )&stAppSerialMsg, 0,0);
			if(++u8FifoRxCAN >= FIFO_SIZE)
			{
				u8FifoRxCAN = 0;
			}
		}
	}

	if(++u16TimeSlice >= 100)
	{
		if(u8TogglePin)
		{
			HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_SET);
		}
		else
		{
			HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET);
		}
		u8TogglePin = !u8TogglePin;

		stAppSerialMsg.ucSrc = SRC_APPCAN;
		stAppSerialMsg.ucDest = SRC_APPCAN;
		stAppSerialMsg.ucEvent = EVENT_APPCAN_TX;
		stAppSerialMsg.pcMessageData = NULL;
		xQueueGenericSend(*xQueueAppSerial, ( void * )&stAppSerialMsg, 0,0);
		if(++u8FifoTxCAN >= FIFO_SIZE)
		{
			u8FifoTxCAN = 0;
		}
		u16TimeSlice = 0;
	}
}


